(defpackage amb
  (:use :cl)
  (:import-from :utils :evaluate)
  (:export :make-machine :parse :value :valid))
(in-package amb)
(defclass machine ()
  ((scheme :initarg :scheme :reader scheme)
   (value :initform nil :accessor value)
   (leftover :initarg :leftover :reader leftover)
   (valid :initform nil :accessor valid)))
(defun make-machine (chars scheme)
  (make-instance 'machine :leftover chars :scheme scheme))
(defmethod save ((m machine) &key userinfo host)
  (setf (value m)
        (append (value m)
                (list (list (scheme m) (evaluate userinfo) (evaluate host)))))
  (setf (valid m) t))
(defmethod save-host ((m machine) host-machine)
  (if (host:valid host-machine) (save m :host (host:value host-machine))))
(defmethod save-both ((m machine) both-machine)
  (if (mailto:valid both-machine)
      (save m
            :host (mailto:host both-machine)
            :userinfo (mailto:userinfo both-machine))))
(defmethod finalize ((m machine) host-machine both-machine)
  (if (host:valid host-machine) (save-host m host-machine))
  (if (mailto:valid both-machine) (save-both m both-machine)))
(defmethod parse-host ((m machine) host-machine)
  (setf (host:leftover host-machine) (leftover m))
  (host:parse host-machine))
(defmethod parse ((m machine))
  (let ((both-machine (mailto:make-machine (leftover m)))
        (host-machine (host:make-machine nil)))
    (mailto:parse both-machine)
    (if (and (mailto:valid both-machine) (not (mailto:host both-machine)))
        (parse-host m host-machine)
        (host:parse host-machine))
    (finalize m host-machine both-machine)))
