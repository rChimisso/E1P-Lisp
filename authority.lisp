(defpackage authority
	(:use :cl :gen-machine)
	(:export :make-machine :parse :host :userinfo :port :leftover :valid :state :current)
)
(in-package authority)
(defclass machine (gen-machine) (
	(userinfo :initform nil :accessor userinfo)
	(host :initform nil :accessor host)
	(port :initform 80 :accessor port)
))
(defun make-machine (chars) (make-instance 'machine :leftover chars))
(defmethod setv ((m machine) &key userinfo host port leftover)
	(setf
		(values (userinfo m) (host m) (port m) (leftover m) (state m))
		(values userinfo host port leftover "final")
	)
)
(defmethod slash-start-p ((m machine) &optional (depth 1))
	(consume m)
	(if (> depth 0)
		(if (and (current m) (char= (current m) #\/))
			(slash-start-p m (1- depth))
		)
		(unconsume m)
	)
)
(defmethod parse-port ((m machine) leftover userinfo host)
	(let ((port-machine (port:make-machine leftover)))
		(port:parse port-machine)
		(if (port:valid port-machine)
			(setv m
				:userinfo userinfo
				:host host
				:port (port:value port-machine)
				:leftover (port:leftover port-machine)
			)
			(move m "error")
		)
	)
)
(defmethod parse-host ((m machine) leftover userinfo)
	(let ((host-machine (host:make-machine leftover)))
		(host:parse host-machine)
		(if	(host:valid host-machine)
			(parse-port m
				(host:leftover host-machine)
				userinfo
				(host:value host-machine)
			)
			(move m "error")
		)
	)
)
(defmethod parse ((m machine))
	(if (slash-start-p m)
		(if (slash-start-p m)
			(let ((user-machine (userinfo:make-machine (leftover m))))
				(userinfo:parse user-machine)
				(if (string= (userinfo:state user-machine) "at")
					(parse-host m
						(userinfo:leftover user-machine)
						(userinfo:value user-machine)
					)
					(parse-host m (leftover m) nil)
				)
			)
			(progn
				(print "one slash?")
				(unconsume m)
				(setf (leftover m) (cons #\/ (leftover m)))
			)
		)
		(move m "error")
	)
)
