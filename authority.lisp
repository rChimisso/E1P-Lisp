(defpackage authority
	(:use :cl :gen-machine)
	(:export :make-machine :parse :host :userinfo :port :leftover :valid)
)
(in-package authority)
(defclass machine (gen-machine) (
	(userinfo :initform nil :accessor userinfo)
	(host :initform nil :accessor host)
	(port :initform nil :accessor port)
))
(defun make-machine (chars) (make-instance 'machine :leftover chars))
(defmethod setv ((m machine) &key userinfo host port)
	(setf
		(values (userinfo m) (host m) (port m) (state m))
		(values userinfo host port "final")
	)
)
(defmethod authority-start-p ((m machine) &optional (depth 2))
	(consume m)
	(if (> depth 0)
		(if (char= (current m) #\/) (authority-start-p m (1- depth)))
		(unconsume m)
	)
)
(defmethod parse-port ((m machine) leftover userinfo-value host-value)
	(let ((port-machine (port:make-machine leftover)))
		(port:parse port-machine)
		(if (port:valid port-machine)
			(setv m
				:userinfo userinfo-value
				:host host-value
				:port (port:value port-machine)
			)
			(move m "error")
		)
	)
)
(defmethod parse-host ((m machine) leftover userinfo-value)
	(let ((host-machine (host:make-machine leftover)))
		(host:parse host-machine)
		(if	(host:valid host-machine)
			(parse-port m
				(host:leftover host-machine)
				userinfo-value
				(host:value host-machine)
			)
			(move m "error")
		)
	)
)
(defmethod parse ((m machine))
	(if (authority-start-p m)
		(let ((user-machine (userinfo:make-machine (leftover m))))
			(userinfo:parse user-machine)
			(if (string= (userinfo:state user-machine) "at")
				(parse-host m
					(userinfo:leftover user-machine)
					(userinfo:value user-machine)
				)
				(parse-host m (leftover m) nil)
			)
		)
		(move m "error")
	)
)
