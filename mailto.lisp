(defpackage mailto
	(:use :cl)
	(:export :make-machine :parse :host :userinfo :valid)
)
(in-package mailto)
(defclass machine () (
	(host :initform nil :accessor host)
	(userinfo :initform nil :accessor userinfo)
	(leftover :initarg :leftover :reader leftover)
	(valid :initform t :accessor valid)
))
(defun make-machine (chars) (make-instance 'machine :leftover chars))
(defun parse-host (host-machine userinfo-machine)
	(setf (host:leftover host-machine) (userinfo:leftover userinfo-machine))
	(host:parse host-machine)
)
(defmethod validate ((m machine) host-machine userinfo-machine)
	(setf
		(valid m)
		(and
			(host:valid host-machine)
			(userinfo:valid userinfo-machine)
			(not (host:leftover host-machine))
		)
	)
)
(defmethod set-values ((m machine) host-machine userinfo-machine)
	(setf (host m) (host:value host-machine))
	(setf (userinfo m) (userinfo:value userinfo-machine))
)
(defmethod parse ((m machine))
	(let
		(
			(userinfo-machine (userinfo:make-machine (leftover m)))
			(host-machine (host:make-machine nil))
		)
		(userinfo:parse userinfo-machine)
		(if (string= (userinfo:state userinfo-machine) "at")
			(parse-host host-machine userinfo-machine)
		)
		(validate m host-machine userinfo-machine)
		(if (valid m) (set-values m host-machine userinfo-machine))
	)
)
